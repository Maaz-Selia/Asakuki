import time
import colorsys
import tinytuya

class DiffuserDevice(tinytuya.Device):

    # Constructor
    def __init__(self, *args, **kwargs):
        # set the default version to None so we do not immediately connect and call status()
        if 'version' not in kwargs or not kwargs['version']:
            kwargs['version'] = None
        super(DiffuserDevice, self).__init__(*args, **kwargs)

        # Default values
        self.power = False
        self.spray = "off"
        self.colour_mode = "2"
        self.colour = "#f39c9c"
        self.brightness = 255
        self.intermittence = False

        data = self.status()
        if isinstance(data, dict):
            self.power = data["dps"]["1"]
            self.spray = data["dps"]["103"]
            self.colour_mode = data["dps"]["110"]
            self.colour = data["dps"]["108"]
            self.brightness = data["dps"]["111"]

    def _rgb_to_tuya(r, g, b):
        """
        Convert an RGB value to the hex representation expected by Tuya Bulb.

        format: rrggbb0hhhssvv

        Args:
            r(int): Value for the colour red as int from 0-255.
            g(int): Value for the colour green as int from 0-255.
            b(int): Value for the colour blue as int from 0-255.
        """
        rgb = [r, g, b]
        hsv = colorsys.rgb_to_hsv(rgb[0] / 255.0, rgb[1] / 255.0, rgb[2] / 255.0)

        """
        # Bulb Type A
        if bulb == "A":
        """
        # h:0-360,s:0-255,v:0-255|hsv|
        hexvalue = ""
        for value in rgb:
            temp = str(hex(int(value))).replace("0x", "")
            if len(temp) == 1:
                temp = "0" + temp
            hexvalue = hexvalue + temp

        hsvarray = [int(hsv[0] * 360), int(hsv[1] * 255), int(hsv[2] * 255)]
        hexvalue_hsv = ""
        for value in hsvarray:
            temp = str(hex(int(value))).replace("0x", "")
            if len(temp) == 1:
                temp = "0" + temp
            hexvalue_hsv = hexvalue_hsv + temp
        if len(hexvalue_hsv) == 7:
            hexvalue = hexvalue + "0" + hexvalue_hsv
        else:
            hexvalue = hexvalue + "00" + hexvalue_hsv

        """
        # Bulb Type B
        if bulb == "B":
            # h:0-360,s:0-1000,v:0-1000|hsv|
            hexvalue = ""
            hsvarray = [int(hsv[0] * 360), int(hsv[1] * 1000), int(hsv[2] * 1000)]
            for value in hsvarray:
                temp = str(hex(int(value))).replace("0x", "")
                while len(temp) < 4:
                    temp = "0" + temp
                hexvalue = hexvalue + temp
        """

        return hexvalue

    def _hex_to_rgb(hexvalue):
            """
            Converts the hexvalue used by Tuya for colour representation into
            an RGB value.

            Args:
                hexvalue(string): The hex representation generated by BulbDevice._rgb_to_hexvalue()
            """
            r = int(hexvalue[0:2], 16)
            g = int(hexvalue[2:4], 16)
            b = int(hexvalue[4:6], 16)

            """
            elif bulb == "B":
                # hexvalue is in hsv
                h = float(int(hexvalue[0:4], 16) / 360.0)
                s = float(int(hexvalue[4:8], 16) / 1000.0)
                v = float(int(hexvalue[8:12], 16) / 1000.0)
                rgb = colorsys.hsv_to_rgb(h, s, v)
                r = int(rgb[0] * 255)
                g = int(rgb[1] * 255)
                b = int(rgb[2] * 255)
            else:
                # Unsupported bulb type
                raise ValueError(f"Unsupported bulb type {bulb} - unable to determine RGB values.")
            """
            return (r, g, b)

    def _hex_to_hsv(hexvalue):
        """
        Converts the hexvalue used by Tuya for colour representation into
        an HSV value.

        Args:
            hexvalue(string): The hex representation generated by BulbDevice._rgb_to_hexvalue()
        """

        h = int(hexvalue[7:10], 16) / 360.0
        s = int(hexvalue[10:12], 16) / 255.0
        v = int(hexvalue[12:14], 16) / 255.0
        """
        elif bulb == "B":
            # hexvalue is in hsv
            h = int(hexvalue[0:4], 16) / 360.0
            s = int(hexvalue[4:8], 16) / 1000.0
            v = int(hexvalue[8:12], 16) / 1000.0
        else:
            # Unsupported bulb type
            raise ValueError(f"Unsupported bulb type {bulb} - unable to determine HSV values.")
        """
        
        return (h, s, v)

    def _hex_to_tuya(hexvalue):

        r = int(hexvalue[0:2], 16)
        g = int(hexvalue[2:4], 16)
        b = int(hexvalue[4:6], 16)

        return DiffuserDevice._rgb_to_tuya(r, g, b)

    # Toggle power
    def toggle_power(self):

        payload = self.generate_payload( 7, {"1": not self.power})
        data = self._send_receive(payload, getresponse=(not False))

        self.power = not self.power

        if self.power:
            self.set_colour(self.colour, self.brightness)
            self.set_spray(self.spray)
        
        return data

    # Set spray
    def set_spray(self, value):

        payload = self.generate_payload( 7, {"103": str(value)})
        data = self._send_receive(payload, getresponse=(not False))

        self.spray = str(value)

        return data

    # Set colour mode
    def set_colour_mode(self, value):

        payload = self.generate_payload( 7, {"110": str(value)})
        data = self._send_receive(payload, getresponse=(not False))

        self.colour_mode = value

        return data

    # Set colour
    def set_colour(self, value, brigthness=255):

        colour = DiffuserDevice._hex_to_tuya(value.replace("#", ""))

        # Send colour mode
        self.set_colour_mode("2")

        # Send colour
        payload = self.generate_payload( 7, {"108": colour})
        data = self._send_receive(payload, getresponse=(not False))

        # Send brightness
        self.set_brightness(brigthness)

        self.colour = value
        
        return data

    # Set brigthness
    def set_brightness(self, value=255):

        payload = self.generate_payload(7, {"111": int(value)})
        data = self._send_receive(payload, getresponse=(not False))

        self.brightness = value

        return data

    # Set intermittence
    def set_intermittence(self, onTime=2.5, offTime=2.5, mode="small", duration=60):
        
        timeElapsed = 0

        while(timeElapsed < duration and self.intermittence):

            payload = self.generate_payload( 7, {"103": mode})
            data = self._send_receive(payload, getresponse=(not False))
            time.sleep(onTime)

            payload = self.generate_payload( 7, {"103": "off"})
            data = self._send_receive(payload, getresponse=(not False))
            time.sleep(offTime)

            timeElapsed = timeElapsed + onTime + offTime
            #print('set_status() result %r' % data)
            #print(timeElapsed)

        return data